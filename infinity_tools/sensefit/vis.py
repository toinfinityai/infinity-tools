import os
import cv2
import json
import glob
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import numpy.typing as npt
from matplotlib.animation import FuncAnimation
from typing import Tuple
from IPython.display import HTML, display
from infinity_tools.common.vis.notebook import display_video_as_gif
from infinity_tools.common.vis.videos import stack_videos
from infinity_tools.sensefit.datagen import SenseFitGenerator


def summarize_batch_results(batch_folder: str) -> pd.DataFrame:
    job_jsons = glob.glob(os.path.join(batch_folder, "**/job.json"), recursive=True)
    rows = []
    for job_json in job_jsons:
        csv_path = job_json.replace("job.json", "data.csv")
        job_metadata = dict()
        job_metadata["job_id"] = os.path.basename(os.path.dirname(job_json))
        job_metadata["num_frames"] = len(pd.read_csv(csv_path))
        job_params = json.load(open(job_json))["params"]
        rows.append({**job_metadata, **job_params})
    df = pd.DataFrame(rows)
    return df


def display_batch_results(batch_folder: str) -> None:
    metadata = summarize_batch_results(batch_folder)
    display(HTML(metadata.to_html()))


def animate_test_video(video_path: str, display_width: int = 600):
    """Plays test video synchronized with animation of time series.

    Args:
        video_path: Path to real-world test video.
        height: Height of new video (RGB + time series animation), in pixels.

    Returns:
        Video playback object for jupyter notebook.
    """
    csv_path = video_path.replace("mp4", "csv")
    ts_path = video_path.replace(".mp4", "_ts.mp4")
    merged_path = video_path.replace(".mp4", "_merged.mp4")

    cap = cv2.VideoCapture(video_path)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    fps = int(cap.get(cv2.CAP_PROP_FPS))

    make_realworld_timeseries_video(csv_path, ts_path, total_frames, fps)
    stack_videos(
        paths=[video_path, ts_path], output_path=merged_path, fixed_size=400, axis=2
    )
    display_video_as_gif(
        video_path=merged_path,
        display_width=display_width,
        downsample_frames=3,
        downsample_resolution=3,
    )


def make_realworld_timeseries_video(
    csv_path: str, output_path: str, total_frames: int, fps: int
):
    """Generates time series animation for real-world data.

    Args:
        csv_path: Path to .csv file generated with 9-axis angular position data.
        output_path: Output path where video will be saved.
        total_frames: Total number of frames that should be used in animation (in
            order to match real-world RGB test video).
        fps: Frame rate of real-world video
    """

    sequence_X, _ = SenseFitGenerator.load_data(csv_path)
    num_data_frames = sequence_X.shape[0]
    data_time = np.arange(num_data_frames) / fps

    fig, ax = plt.subplots(1, 1, figsize=(4, 1.6), dpi=150)
    ax.plot(data_time, sequence_X.reshape(-1, 9))
    ax.set_title("9DOF Rotation Matrix")
    ax.set_xlabel("Time [s]")

    (line0,) = ax.plot([0, 0], [-1, 1], color="red")
    fig.tight_layout()

    def update(frame: int, video_time: npt.NDArray, max_time: float):
        current_time = video_time[frame]
        if current_time <= 0 or current_time >= max_time:
            return
        line0.set_data([current_time, current_time], [-1, 1])

    interval = 1000 / fps
    video_time = np.arange(total_frames) / fps
    max_time = num_data_frames / fps

    anim = FuncAnimation(
        fig=fig,
        func=update,
        frames=total_frames,
        fargs=(video_time, max_time),
        interval=interval,
        blit=False,
    )

    anim.save(output_path)
    plt.close()


def visualize_job(job_folder: str, display_width: int = 600):
    """Visualizes the time series + motion video associated with a job.
    Args:
        job_folder: Path to folder where data from one job has been saved.
    Returns:
        Video playback object for jupyter notebook.
    """

    csv_path = os.path.join(job_folder, "data.csv")
    rgb_video_path = os.path.join(job_folder, "video.mp4")
    ts_video_path = os.path.join(job_folder, "timeseries.mp4")
    merged_path = os.path.join(job_folder, "merged.mp4")

    make_synthetic_timeseries_video(csv_path, ts_video_path)
    stack_videos(
        paths=[ts_video_path, rgb_video_path],
        fixed_size=400,
        output_path=merged_path,
        axis=2,
    )
    display_video_as_gif(
        video_path=merged_path,
        display_width=display_width,
        downsample_frames=3,
        downsample_resolution=1,
    )


def make_synthetic_timeseries_video(csv_path: str, output_path: str):
    """Generates time series animation for synthetic data.

    Args:
        csv_path: Path to .csv file generated by Infinity API with IMU data.
        output_path: Output path where video will be saved.
    """

    sequence_X, sequence_y = SenseFitGenerator.load_data(csv_path)
    data_time = pd.read_csv(csv_path)["time"]
    num_data_frames = sequence_X.shape[0]

    fig, ax = plt.subplots(2, 1, figsize=(4, 3.2), dpi=150)
    ax[0].plot(data_time, sequence_X.reshape(-1, 9))
    ax[0].set_title("9DOF Rotation Matrix")

    ax[1].plot(data_time, sequence_y)
    ax[1].set_title("Rep Count")
    ax[1].grid("on")
    ax[1].set_xlabel("Time [s]")

    ylim1 = ax[1].get_ylim()
    (line0,) = ax[0].plot([0, 0], [-1, 1], color="red")
    (line1,) = ax[1].plot([0, 0], ylim1, color="red")

    fig.tight_layout()

    def update(frame: int, data_time: npt.NDArray, ylim1: Tuple[float, float]):
        line0.set_data([data_time[frame], data_time[frame]], [-1, 1])
        line1.set_data([data_time[frame], data_time[frame]], ylim1)

    interval = 1000 * (data_time[1] - data_time[0])
    anim = FuncAnimation(
        fig=fig,
        func=update,
        frames=num_data_frames,
        fargs=(
            data_time,
            ylim1,
        ),
        interval=interval,
        blit=False,
    )

    anim.save(output_path)
    plt.close()


def plot_predictions(data_path, pred_count):
    sequence_X, _ = SenseFitGenerator.load_data(data_path)
    fig, ax = plt.subplots(2, 1, figsize=(4, 3.2), dpi=150)
    ax[0].plot(sequence_X.reshape(-1, 9))
    ax[0].set_title("9DOF Rotation Matrix")
    ax[1].plot(pred_count)
    ax[1].set_title("Predicted Rep Count")
    for _ax in ax:
        _ax.set_xlabel("Samples")
    fig.tight_layout()
